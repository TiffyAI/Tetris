<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TiffyAI Tetrus</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Web3 & Web3Modal -->
  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  <script src="https://unpkg.com/web3modal@1.9.12/dist/index.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: url('Tetrus.jpg') no-repeat center center fixed;
      background-size: cover;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      overflow: hidden;
      color: #0ff;
      position: relative;
    }
    h1 {
      text-shadow: 0 0 10px #f0f, 0 0 20px #0ff;
      margin: 10px 0 5px;
    }
    canvas {
      border: 4px solid #0ff;
      box-shadow: 0 0 20px #0ff;
      background-color: rgba(0, 0, 0, 0.7);
      width: 80vw;
      max-width: 300px;
      height: 60vh;
    }
    #score {
      margin-top: 10px;
      font-size: 18px;
      text-shadow: 0 0 5px #0ff;
    }
    .action-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .action-buttons button {
      padding: 8px 16px;
      font-size: 14px;
      font-weight: bold;
      background: linear-gradient(90deg, #00ffff, #ff00ff);
      border: none;
      border-radius: 10px;
      color: white;
      text-shadow: 0 0 5px #fff;
      box-shadow: 0 0 20px #0ff;
      cursor: pointer;
      min-width: 100px;
    }
    .action-buttons button:active {
      transform: scale(0.95);
    }
    #touch-controls {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    .control-btn {
      background: rgba(0, 255, 255, 0.2);
      border: 2px solid #0ff;
      border-radius: 10px;
      width: 60px;
      height: 60px;
      font-size: 24px;
      color: #fff;
      text-shadow: 0 0 5px #0ff;
      box-shadow: 0 0 10px #00ffff;
      cursor: pointer;
      user-select: none;
    }
    .control-btn:active {
      background-color: rgba(0, 255, 255, 0.5);
    }
    #bonus-animation {
      position: absolute;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0;
      animation: none;
      z-index: 999;
      pointer-events: none;
    }
    @keyframes bonusFade {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -150%) scale(1.4);
      }
    }
    /* Wallet info panel */
    #walletInfo {
      margin-top: 15px;
      font-size: 14px;
      color: #0ff;
      text-shadow: 0 0 5px #00ffff;
      user-select: text;
      max-width: 320px;
      word-break: break-word;
      text-align: center;
    }
    #walletInfo span {
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>TiffyAI Tetrus</h1>
  <canvas id="tetris" width="300" height="600"></canvas>
  <div id="score">üí∞ TIFFY: 0.00000000</div>

  <div class="action-buttons">
    <button id="restartBtn">RESTART</button>
    <button id="connectBtn">CONNECT WALLET</button>
    <button id="withdrawBtn" style="display:none;">WITHDRAW</button>
  </div>

  <div id="walletInfo" style="display:none;">
    Connected wallet: <span id="walletAddress">-</span><br/>
    Your claimed TIFFY: <span id="tiffyCount">0</span><br/>
    Live price: $<span id="livePrice">-</span><br/>
    USD Value: $<span id="usdValue">0.00</span>
  </div>

  <!-- Touch Controls -->
  <div id="touch-controls">
    <button class="control-btn" onclick="handleTouch('left')">‚¨ÖÔ∏è</button>
    <button class="control-btn" onclick="handleTouch('rotate')">üîÑ</button>
    <button class="control-btn" onclick="handleTouch('right')">‚û°Ô∏è</button>
  </div>

  <!-- Bonus Animation -->
  <img id="bonus-animation" src="TiffyAI-Token.png" width="120" />

  <!-- Sounds -->
  <audio id="rowSound" src="row.wav" preload="auto"></audio>
  <audio id="overSound" src="over.wav" preload="auto"></audio>
  <audio id="clickSound" src="click.wav" preload="auto"></audio>
  <audio id="withdrawSound" src="withdraw.wav" preload="auto"></audio>

  <script>
  (function(){
    // === Game Setup ===
    const canvas = document.getElementById("tetris");
    const ctx = canvas.getContext("2d");
    const rowSound = document.getElementById("rowSound");
    const overSound = document.getElementById("overSound");
    const clickSound = document.getElementById("clickSound");
    const withdrawSound = document.getElementById("withdrawSound");
    const restartBtn = document.getElementById("restartBtn");
    const withdrawBtn = document.getElementById("withdrawBtn");
    const connectBtn = document.getElementById("connectBtn");
    const scoreDisplay = document.getElementById("score");
    const bonusImg = document.getElementById("bonus-animation");

    const walletInfo = document.getElementById("walletInfo");
    const walletAddressDisplay = document.getElementById("walletAddress");
    const tiffyCountDisplay = document.getElementById("tiffyCount");
    const livePriceDisplay = document.getElementById("livePrice");
    const usdValueDisplay = document.getElementById("usdValue");

    const ROWS = 20;
    const COLS = 10;
    const BLOCK_SIZE = 30;
    const board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    const colors = ['#000', '#0ff', '#f0f', '#0f0', '#ff0', '#f00', '#00f', '#0f9'];

    let score = parseFloat(localStorage.getItem('tetrusScore')) || 0;
    let dropInterval = 500;
    let dropCounter = 0;
    let lastTime = 0;
    let gameOver = false;

    let piece = {
      matrix: createPiece('T'),
      pos: {x: 3, y: 0}
    };

    // === Blockchain / Wallet Setup ===
    const contractAddress = "0xE488253DD6B4D31431142F1b7601C96f24Fb7dd5";
    const contractABI = [
      {inputs:[],name:"claim",outputs:[],stateMutability:"payable",type:"function"},
      {inputs:[],name:"FIXED_BNB_FEE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}
    ];
    const BACKEND = "https://tiffyai-wh-wa.onrender.com/reward";

    let web3;
    let provider;
    let account = null;
    let contract;
    let fee = null;

    // -- Functions --

    function drawMatrix(matrix, offset) {
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            ctx.fillStyle = colors[value];
            ctx.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#222';
            ctx.strokeRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          }
        });
      });
    }

    function createPiece(type) {
      const pieces = {
        T: [[0,1,0],[1,1,1],[0,0,0]],
        O: [[2,2],[2,2]],
        L: [[0,0,3],[3,3,3],[0,0,0]],
        J: [[4,0,0],[4,4,4],[0,0,0]],
        I: [[0,0,0,0],[5,5,5,5],[0,0,0,0]],
        S: [[0,6,6],[6,6,0],[0,0,0]],
        Z: [[7,7,0],[0,7,7],[0,0,0]]
      };
      return pieces[type];
    }

    function merge(board, piece) {
      piece.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            board[y + piece.pos.y][x + piece.pos.x] = value;
          }
        });
      });
    }

    function collide(board, piece) {
      for (let y = 0; y < piece.matrix.length; ++y) {
        for (let x = 0; x < piece.matrix[y].length; ++x) {
          if (piece.matrix[y][x] !== 0 &&
              (board[y + piece.pos.y] && board[y + piece.pos.y][x + piece.pos.x]) !== 0) {
            return true;
          }
        }
      }
      return false;
    }

    function playerDrop() {
      piece.pos.y++;
      if (collide(board, piece)) {
        piece.pos.y--;
        merge(board, piece);
        resetPiece();
        sweepRows();
      }
      dropCounter = 0;
    }

    function sweepRows() {
      let rowsCleared = 0;
      outer: for (let y = board.length - 1; y >= 0; y--) {
        for (let x = 0; x < board[y].length; x++) {
          if (board[y][x] === 0) continue outer;
        }
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(0));
        rowsCleared++;
      }

      if (rowsCleared > 0) {
        rowSound.play();
        score += rowsCleared * 0.05;

        if (rowsCleared >= 2) {
          score += 1;
          triggerBonusAnimation();
        }

        localStorage.setItem('tetrusScore', score);
        updateScore();
      }
    }

    function resetPiece() {
      const pieces = 'TJLOSZI';
      piece.matrix = createPiece(pieces[Math.floor(Math.random() * pieces.length)]);
      piece.pos.y = 0;
      piece.pos.x = Math.floor(COLS / 2) - Math.floor(piece.matrix[0].length / 2);
      if (collide(board, piece)) {
        overSound.play();
        alert("Game Over! üí∞ TIFFY: " + score.toFixed(8));
        gameOver = true;
      }
    }

    function update(time = 0) {
      if (gameOver) return;
      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) {
        playerDrop();
      }
      draw();
      requestAnimationFrame(update);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMatrix(board, {x: 0, y: 0});
      drawMatrix(piece.matrix, piece.pos);
    }

    function updateScore() {
      scoreDisplay.textContent = "üí∞ TIFFY: " + score.toFixed(8);
      updateWalletDisplay(); // update wallet display on score change
    }

    function handleTouch(action) {
      if (gameOver) return;
      if (action === 'left') piece.pos.x--;
      if (action === 'right') piece.pos.x++;
      if (action === 'down') playerDrop();
      if (action === 'rotate') {
        piece.matrix = piece.matrix[0].map((_, i) => piece.matrix.map(row => row[i])).reverse();
        if (collide(board, piece)) {
          piece.matrix = piece.matrix[0].map((_, i) => piece.matrix.map(row => row[row.length - 1 - i]));
        }
      }
    }

    function triggerBonusAnimation() {
      bonusImg.style.animation = "none";
      void bonusImg.offsetWidth;
      bonusImg.style.animation = "bonusFade 2s ease-out forwards";
    }

    // === Blockchain wallet functions ===

    // Web3Modal setup
    const web3Modal = new Web3Modal.default({
      cacheProvider: false,
      providerOptions: {
        walletconnect: {
          package: window.WalletConnectProvider?.default || null,
          options: {
            rpc: {
              56: "https://bsc-dataseed.binance.org/"
            }
          }
        }
      }
    });

    async function connectWallet() {
      try {
        provider = await web3Modal.connect();
        web3 = new Web3(provider);

        // Check chain id & switch if needed
        const chainId = await web3.eth.getChainId();
        if(chainId !== 56){
          try {
            await provider.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: "0x38" }],
            });
          } catch (switchError) {
            // try add chain for some wallets
            if(provider.isBitget || provider.isBitKeep){
              try {
                await provider.request({
                  method: "wallet_addEthereumChain",
                  params: [{
                    chainId: "0x38",
                    chainName: "BNB Smart Chain",
                    rpcUrls: ["https://bsc-dataseed.binance.org/"],
                    nativeCurrency: { name: "BNB", symbol: "BNB", decimals: 18 },
                    blockExplorerUrls: ["https://bscscan.com"]
                  }]
                });
              } catch {
                alert("üåê Bitget: please switch BSC manually.");
                return;
              }
            } else {
              alert("‚ùó Please switch to BNB Smart Chain");
              return;
            }
          }
        }

        const accounts = await web3.eth.getAccounts();
        account = accounts[0];
        contract = new web3.eth.Contract(contractABI, contractAddress);
        fee = await contract.methods.FIXED_BNB_FEE().call();

        walletAddressDisplay.textContent = account;
        walletInfo.style.display = "block";
        withdrawBtn.style.display = "inline-block";
        connectBtn.style.display = "none";

        updateWalletDisplay();
      } catch (err) {
        alert("‚ùå Wallet connection failed: " + (err.message || err));
      }
    }

    // Withdraw function as per your logic
    async function withdraw() {
      if (!account || !contract) {
        alert("‚ö†Ô∏è Connect your wallet first!");
        return;
      }
      const key = `tiffyClaimed_${account}`;
      let claimedCount = parseInt(localStorage.getItem(key) || "0");
      if(claimedCount <= 0){
        alert("You have no TIFFY to withdraw.");
        return;
      }

      withdrawBtn.disabled = true;
      withdrawBtn.textContent = "Processing...";
      withdrawSound.play();

      try {
        await contract.methods.claim().send({ from: account, value: fee });

        // After contract call, call backend for rest of amount if any
        const backendAmt = claimedCount - 1;
        if(backendAmt > 0){
          await fetch(BACKEND, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({ wallet: account, amount: backendAmt })
          });
        }

        localStorage.setItem(key, "0");
        alert("‚úÖ Withdrawal Complete!");
        updateWalletDisplay();
      } catch (e) {
        alert("‚ùå Withdraw failed: " + (e.message || e));
      }

      withdrawBtn.disabled = false;
      withdrawBtn.textContent = "WITHDRAW";
    }

    function updateWalletDisplay() {
      if(!account) return;
      const key = `tiffyClaimed_${account}`;
      const claimedCount = parseInt(localStorage.getItem(key) || "0");
      tiffyCountDisplay.textContent = claimedCount;
      const price = parseFloat(livePriceDisplay.textContent) || 0;
      usdValueDisplay.textContent = (claimedCount * price).toFixed(2);
      withdrawBtn.style.display = claimedCount > 0 ? "inline-block" : "none";
    }

    async function fetchLivePrice() {
      try {
        // You can change the path or API here if needed
        const response = await fetch("/TIFFY-Market-Value/price.json");
        const data = await response.json();
        const price = parseFloat(data.tiffyToUSD);
        if(!isNaN(price)){
          livePriceDisplay.textContent = price.toFixed(2);
          updateWalletDisplay();
        }
      } catch {
        livePriceDisplay.textContent = "-";
      }
    }

    // Connect button handler
    connectBtn.onclick = connectWallet;

    // Withdraw button handler
    withdrawBtn.onclick = withdraw;

    // === Game buttons ===
    restartBtn.addEventListener("click", () => {
      clickSound.play();
      for (let y = 0; y < ROWS; y++) {
        board[y].fill(0);
      }
      gameOver = false;
      resetPiece();
      update();
    });

    // === Touch control handler ===
    window.handleTouch = handleTouch;

    // === Game Init ===
    updateScore();
    resetPiece();
    update();
    fetchLivePrice();
    setInterval(fetchLivePrice, 60000);

  })();
  </script>
</body>
</html>
