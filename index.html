<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TiffyAI Tetris</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Web3 & Web3Modal (v1 used here; we'll migrate to v2 when you provide your v2 code) -->
  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  <script src="https://unpkg.com/web3modal@1.9.12/dist/index.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: url('Tetrus.jpg') no-repeat center center fixed;
      background-size: cover;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      overflow: hidden;
      color: #0ff;
      position: relative;
    }
    h1 {
      text-shadow: 0 0 10px #f0f, 0 0 20px #0ff;
      margin: 10px 0 5px;
    }
    canvas {
      border: 4px solid #0ff;
      box-shadow: 0 0 20px #0ff;
      background-color: rgba(0, 0, 0, 0.7);
      width: 80vw;
      max-width: 300px;
      height: 60vh;
    }
    #score {
      margin-top: 10px;
      font-size: 18px;
      text-shadow: 0 0 5px #0ff;
    }
    .action-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .action-buttons button {
      padding: 8px 16px;
      font-size: 14px;
      font-weight: bold;
      background: linear-gradient(90deg, #00ffff, #ff00ff);
      border: none;
      border-radius: 10px;
      color: white;
      text-shadow: 0 0 5px #fff;
      box-shadow: 0 0 20px #0ff;
      cursor: pointer;
      min-width: 100px;
    }
    .action-buttons button:active {
      transform: scale(0.95);
    }
    #touch-controls {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    .control-btn {
      background: rgba(0, 255, 255, 0.2);
      border: 2px solid #0ff;
      border-radius: 10px;
      width: 60px;
      height: 60px;
      font-size: 24px;
      color: #fff;
      text-shadow: 0 0 5px #0ff;
      box-shadow: 0 0 10px #00ffff;
      cursor: pointer;
      user-select: none;
    }
    .control-btn:active {
      background-color: rgba(0, 255, 255, 0.5);
    }
    #bonus-animation {
      position: absolute;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0;
      animation: none;
      z-index: 999;
      pointer-events: none;
    }
    @keyframes bonusFade {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -150%) scale(1.4);
      }
    }
    /* Wallet info panel */
    #walletInfo {
      margin-top: 15px;
      font-size: 14px;
      color: #0ff;
      text-shadow: 0 0 5px #00ffff;
      user-select: text;
      max-width: 320px;
      word-break: break-word;
      text-align: center;
    }
    #walletInfo span {
      font-weight: bold;
    }
    /* small modal for fee confirmation */
    #feeModal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95);
      border: 2px solid #0ff;
      padding: 18px;
      border-radius: 10px;
      color: #0ff;
      display: none;
      z-index: 2000;
      width: 90%;
      max-width: 400px;
      text-align: left;
      box-shadow: 0 0 30px rgba(0,255,255,0.08);
    }
    #feeModal h3 { margin-top:0; text-align:center; }
    #feeModal .row { display:flex; justify-content:space-between; margin:8px 0; }
    #feeModal .actions { display:flex; justify-content:space-between; gap:10px; margin-top:12px; }
    #feeModal button { flex:1; padding:10px; border-radius:8px; border:none; font-weight:bold; cursor:pointer; }
    #feeModal .cancel { background:#222; color:#fff; border:1px solid #444; }
    #feeModal .confirm { background:linear-gradient(90deg,#00ffcc,#00aaff); color:#000; }
  </style>
</head>
<body>
  <h1>TiffyAI Tetris</h1>
  <canvas id="tetris" width="300" height="600"></canvas>
  <div id="score">üí∞ TIFFY: 0.00000000</div>

  <div class="action-buttons">
    <button id="restartBtn">RESTART</button>
    <button id="connectBtn">CONNECT & WITHDRAW</button>
    <button id="withdrawBtn" style="display:none;">WITHDRAW</button>
  </div>

  <div id="walletInfo" style="display:none;">
    Connected wallet: <span id="walletAddress">-</span><br/>
    Your claimed TIFFY: <span id="tiffyCount">0</span><br/>
    Live price: $<span id="livePrice">-</span><br/>
    USD Value: $<span id="usdValue">0.00</span>
  </div>

  <!-- Fee modal -->
  <div id="feeModal" role="dialog" aria-modal="true">
    <h3>Confirm Withdrawal</h3>
    <div class="row"><div>Contract fee:</div><div id="modalContractFee">- BNB</div></div>
    <div class="row"><div>Estimated network fee:</div><div id="modalGasFee">- BNB</div></div>
    <div class="row"><div><strong>Total estimate:</strong></div><div id="modalTotal">- BNB</div></div>
    <div class="row"><div>Approx USD:</div><div id="modalUSD">-</div></div>
    <div style="font-size:12px;margin-top:8px;color:#aaffff;">This is an estimate. MetaMask will show final gas before you confirm.</div>
    <div class="actions">
      <button class="cancel" id="feeCancel">Cancel</button>
      <button class="confirm" id="feeConfirm">Proceed</button>
    </div>
  </div>

  <!-- Touch Controls -->
  <div id="touch-controls">
    <button class="control-btn" onclick="handleTouch('left')">‚¨ÖÔ∏è</button>
    <button class="control-btn" onclick="handleTouch('rotate')">üîÑ</button>
    <button class="control-btn" onclick="handleTouch('right')">‚û°Ô∏è</button>
  </div>

  <!-- Bonus Animation -->
  <img id="bonus-animation" src="TiffyAI-Token.png" width="120" />

  <!-- Sounds -->
  <audio id="rowSound" src="row.wav" preload="auto"></audio>
  <audio id="overSound" src="over.wav" preload="auto"></audio>
  <audio id="clickSound" src="click.wav" preload="auto"></audio>
  <audio id="withdrawSound" src="withdraw.wav" preload="auto"></audio>

  <script>
  (function(){
    // === Game Setup === (kept exactly)
    const canvas = document.getElementById("tetris");
    const ctx = canvas.getContext("2d");
    const rowSound = document.getElementById("rowSound");
    const overSound = document.getElementById("overSound");
    const clickSound = document.getElementById("clickSound");
    const withdrawSound = document.getElementById("withdrawSound");
    const restartBtn = document.getElementById("restartBtn");
    const withdrawBtn = document.getElementById("withdrawBtn");
    const connectBtn = document.getElementById("connectBtn");
    const scoreDisplay = document.getElementById("score");
    const bonusImg = document.getElementById("bonus-animation");

    const walletInfo = document.getElementById("walletInfo");
    const walletAddressDisplay = document.getElementById("walletAddress");
    const tiffyCountDisplay = document.getElementById("tiffyCount");
    const livePriceDisplay = document.getElementById("livePrice");
    const usdValueDisplay = document.getElementById("usdValue");

    // modal elements
    const feeModal = document.getElementById("feeModal");
    const modalContractFee = document.getElementById("modalContractFee");
    const modalGasFee = document.getElementById("modalGasFee");
    const modalTotal = document.getElementById("modalTotal");
    const modalUSD = document.getElementById("modalUSD");
    const feeCancel = document.getElementById("feeCancel");
    const feeConfirm = document.getElementById("feeConfirm");

    const ROWS = 20;
    const COLS = 10;
    const BLOCK_SIZE = 30;
    const board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    const colors = ['#000', '#0ff', '#f0f', '#0f0', '#ff0', '#f00', '#00f', '#0f9'];

    let score = parseFloat(localStorage.getItem('tetrusScore')) || 0;
    let dropInterval = 500;
    let dropCounter = 0;
    let lastTime = 0;
    let gameOver = false;

    let piece = {
      matrix: createPiece('T'),
      pos: {x: 3, y: 0}
    };

    // === Blockchain / Wallet Setup === (your contract info)
    const contractAddress = "0xE488253DD6B4D31431142F1b7601C96f24Fb7dd5";
    const contractABI = [
      {inputs:[],name:"claim",outputs:[],stateMutability:"payable",type:"function"},
      {inputs:[],name:"FIXED_BNB_FEE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}
    ];
    const BACKEND = "https://tiffyai-wh-wa.onrender.com/reward";

    let web3;
    let provider;
    let account = null;
    let contract;
    let fee = null;

    // Web3Modal v1 setup (keeps support for many wallets via WalletConnect v1)
    const web3Modal = new Web3Modal.default({
      cacheProvider: false,
      providerOptions: {
        walletconnect: {
          package: window.WalletConnectProvider?.default || null,
          options: { rpc: { 56: "https://bsc-dataseed.binance.org/" } }
        }
      }
    });

    // ===== Game functions (kept same as your file) =====
    function drawMatrix(matrix, offset) {
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            ctx.fillStyle = colors[value];
            ctx.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#222';
            ctx.strokeRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          }
        });
      });
    }
    function createPiece(type) {
      const pieces = {
        T: [[0,1,0],[1,1,1],[0,0,0]],
        O: [[2,2],[2,2]],
        L: [[0,0,3],[3,3,3],[0,0,0]],
        J: [[4,0,0],[4,4,4],[0,0,0]],
        I: [[0,0,0,0],[5,5,5,5],[0,0,0,0]],
        S: [[0,6,6],[6,6,0],[0,0,0]],
        Z: [[7,7,0],[0,7,7],[0,0,0]]
      };
      return pieces[type];
    }
    function merge(board, piece) {
      piece.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            board[y + piece.pos.y][x + piece.pos.x] = value;
          }
        });
      });
    }
    function collide(board, piece) {
      for (let y = 0; y < piece.matrix.length; ++y) {
        for (let x = 0; x < piece.matrix[y].length; ++x) {
          if (piece.matrix[y][x] !== 0 &&
              (board[y + piece.pos.y] && board[y + piece.pos.y][x + piece.pos.x]) !== 0) {
            return true;
          }
        }
      }
      return false;
    }
    function playerDrop() {
      piece.pos.y++;
      if (collide(board, piece)) {
        piece.pos.y--;
        merge(board, piece);
        resetPiece();
        sweepRows();
      }
      dropCounter = 0;
    }
    function sweepRows() {
      let rowsCleared = 0;
      outer: for (let y = board.length - 1; y >= 0; y--) {
        for (let x = 0; x < board[y].length; x++) {
          if (board[y][x] === 0) continue outer;
        }
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(0));
        rowsCleared++;
      }
      if (rowsCleared > 0) {
        rowSound.play();
        score += rowsCleared * 0.05;
        if (rowsCleared >= 2) {
          score += 1;
          triggerBonusAnimation();
        }
        localStorage.setItem('tetrusScore', score);
        updateScore();
      }
    }
    function resetPiece() {
      const pieces = 'TJLOSZI';
      piece.matrix = createPiece(pieces[Math.floor(Math.random() * pieces.length)]);
      piece.pos.y = 0;
      piece.pos.x = Math.floor(COLS / 2) - Math.floor(piece.matrix[0].length / 2);
      if (collide(board, piece)) {
        overSound.play();
        alert("Game Over! üí∞ TIFFY: " + score.toFixed(8));
        gameOver = true;
      }
    }
    function update(time = 0) {
      if (gameOver) return;
      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) playerDrop();
      draw();
      requestAnimationFrame(update);
    }
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMatrix(board, {x: 0, y: 0});
      drawMatrix(piece.matrix, piece.pos);
    }
    function updateScore() {
      scoreDisplay.textContent = "üí∞ TIFFY: " + score.toFixed(8);
      updateWalletDisplay();
    }
    function handleTouch(action) {
      if (gameOver) return;
      if (action === 'left') piece.pos.x--;
      if (action === 'right') piece.pos.x++;
      if (action === 'down') playerDrop();
      if (action === 'rotate') {
        piece.matrix = piece.matrix[0].map((_, i) => piece.matrix.map(row => row[i])).reverse();
        if (collide(board, piece)) piece.matrix = piece.matrix[0].map((_, i) => piece.matrix.map(row => row[row.length - 1 - i]));
      }
    }
    function triggerBonusAnimation() {
      bonusImg.style.animation = "none";
      void bonusImg.offsetWidth;
      bonusImg.style.animation = "bonusFade 2s ease-out forwards";
    }

    // ===== Wallet functions =====
    async function connectWallet() {
      try {
        provider = await web3Modal.connect();
        web3 = new Web3(provider);

        // Ensure BSC
        const chainId = await web3.eth.getChainId();
        if(chainId !== 56){
          try {
            await provider.request({ method: "wallet_switchEthereumChain", params: [{ chainId: "0x38" }] });
          } catch (switchError) {
            if(provider.isBitget || provider.isBitKeep){
              try {
                await provider.request({
                  method: "wallet_addEthereumChain",
                  params: [{ chainId:"0x38", chainName:"BNB Smart Chain", rpcUrls:["https://bsc-dataseed.binance.org/"], nativeCurrency:{name:"BNB",symbol:"BNB",decimals:18}, blockExplorerUrls:["https://bscscan.com"]}]
                });
              } catch { alert("üåê Bitget: please switch BSC manually."); return; }
            } else { alert("‚ùó Please switch to BNB Smart Chain"); return; }
          }
        }

        const accounts = await web3.eth.getAccounts();
        account = accounts[0];
        contract = new web3.eth.Contract(contractABI, contractAddress);
        fee = await contract.methods.FIXED_BNB_FEE().call();

        walletAddressDisplay.textContent = account;
        walletInfo.style.display = "block";
        withdrawBtn.style.display = "inline-block";
        connectBtn.style.display = "none";

        updateWalletDisplay();
      } catch (err) {
        alert("‚ùå Wallet connection failed: " + (err.message || err));
      }
    }

    // Show a fee breakdown before opening MetaMask confirm
    async function preConfirmAndSend() {
      // we are connected (this function should be called only after connection)
      if (!account || !contract) { alert("Connect wallet first."); return; }

      // read fixed fee (already read at connect but read again to be safe)
      try { fee = await contract.methods.FIXED_BNB_FEE().call(); } catch (e) { console.error("Can't read FIXED_BNB_FEE:", e); }

      // estimate gas
      let estimatedGas = 150000; // fallback
      let gasPrice = await web3.eth.getGasPrice().catch(()=>null);
      try {
        estimatedGas = await contract.methods.claim().estimateGas({ from: account, value: fee });
      } catch (err) {
        // estimation might fail on some wallets; leave fallback
        console.warn("estimateGas failed, using fallback:", err);
      }
      if(!gasPrice) gasPrice = await web3.eth.getGasPrice().catch(()=> "20000000000"); // fallback 20 gwei

      // calculate gas fee in wei then convert to BNB
      const gasBNIWei = BigInt(estimatedGas) * BigInt(gasPrice);
      const gasBNB = parseFloat(web3.utils.fromWei(gasBNIWei.toString(), "ether"));

      const feeBNB = parseFloat(web3.utils.fromWei(fee.toString(), "ether"));
      const totalBNB = feeBNB + gasBNB;

      // approximate USD using live price (if available)
      let livePrice = parseFloat(livePriceDisplay.textContent) || 0;
      const approxUSD = (totalBNB * livePrice).toFixed(2);

      // show modal with breakdown
      modalContractFee.textContent = feeBNB.toFixed(6) + " BNB";
      modalGasFee.textContent = gasBNB.toFixed(6) + " BNB";
      modalTotal.textContent = totalBNB.toFixed(6) + " BNB";
      modalUSD.textContent = "$" + approxUSD;
      feeModal.style.display = "block";

      // handle cancel/confirm
      return new Promise((resolve) => {
        feeCancel.onclick = () => { feeModal.style.display = "none"; resolve(false); };
        feeConfirm.onclick = () => { feeModal.style.display = "none"; resolve({ estimatedGas, gasPrice }); };
      });
    }

    // Withdraw flow that uses preConfirmAndSend
    async function withdraw() {
      if (!account || !contract) {
        // connect first if needed
        await connectWallet();
        if(!account) return;
      }

      const key = `tiffyClaimed_${account}`;
      let claimedCount = parseInt(localStorage.getItem(key) || "0");
      if(claimedCount <= 0){ alert("You have no TIFFY to withdraw."); return; }

      // show the pre-confirm breakdown and wait for confirmation
      const choice = await preConfirmAndSend();
      if(!choice) return; // user canceled
      const { estimatedGas, gasPrice } = choice;

      // play sound and update UI
      withdrawBtn.disabled = true;
      withdrawBtn.textContent = "Processing...";
      withdrawSound.play();

      try {
        // send transaction with explicit gas/gasPrice to avoid wild auto-suggests
        const receipt = await contract.methods.claim().send({
          from: account,
          value: fee,
          gas: Math.floor(estimatedGas * 1.2), // add small buffer
          gasPrice: gasPrice
        });

        // backend logging for remainder (claimedCount - 1)
        const backendAmt = claimedCount - 1;
        if (backendAmt > 0) {
          await fetch(BACKEND, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({ wallet: account, amount: backendAmt })
          }).catch(e=>console.warn("Backend log failed:", e));
        }

        localStorage.setItem(key, "0");
        alert("‚úÖ Withdrawal Complete!");
        updateWalletDisplay();
      } catch (e) {
        console.error(e);
        alert("‚ùå Withdraw failed: " + (e.message || e));
      } finally {
        withdrawBtn.disabled = false;
        withdrawBtn.textContent = "WITHDRAW";
      }
    }

    function updateWalletDisplay() {
      if(!account) return;
      const key = `tiffyClaimed_${account}`;
      const claimedCount = parseInt(localStorage.getItem(key) || "0");
      tiffyCountDisplay.textContent = claimedCount;
      const price = parseFloat(livePriceDisplay.textContent) || 0;
      usdValueDisplay.textContent = (claimedCount * price).toFixed(2);
      withdrawBtn.style.display = claimedCount > 0 ? "inline-block" : "none";
    }

    async function fetchLivePrice() {
      try {
        const response = await fetch("/TIFFY-Market-Value/price.json");
        const data = await response.json();
        const price = parseFloat(data.tiffyToUSD);
        if(!isNaN(price)) {
          livePriceDisplay.textContent = price.toFixed(2);
          updateWalletDisplay();
        }
      } catch {
        livePriceDisplay.textContent = "-";
      }
    }

    // UI handlers
    connectBtn.onclick = async () => {
      await connectWallet();
      // optional: after connecting, request withdraw immediately if user intended
      // we won't auto-withdraw ‚Äî user uses Withdraw button
    };
    withdrawBtn.onclick = withdraw;

    // Game buttons
    restartBtn.addEventListener("click", () => {
      clickSound.play();
      for (let y = 0; y < ROWS; y++) board[y].fill(0);
      gameOver = false;
      resetPiece();
      update();
    });

    window.handleTouch = handleTouch;

    // Init
    updateScore();
    resetPiece();
    update();
    fetchLivePrice();
    setInterval(fetchLivePrice, 60000);

  })();
  </script>
</body>
</html>
